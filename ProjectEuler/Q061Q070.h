#include <iostream>
#include <vector>
#include <algorithm> // std::max

#include "ifstream_with_path.h"
#include "vector_int.h"
#include "shape_number.h"
#include "sqrt_cont_frac.h"
#include "magic_five_gon.h"
#include "factors_helper.h"
#include "number_helper.h"
#include "permutation_helper.h"

//---------------------------------------------------------------
// Copyright © (2016) Anthony Das
//---------------------------------------------------------------
// https://projecteuler.net


bool recursive_cyclic_shapes(const int &front, shape_number_collection<int> &shape_collection, std::vector<bool> &shapes_used, std::vector<int> &shapes) {
	if (shapes.size() == shapes_used.size()) {
		// Last two digits of final number must match first two digits of first number
		int front_two_digits = shapes.front();
		front_two_digits /= 10;
		front_two_digits /= 10;
		return front_two_digits == shapes.back() % 100 ? true : false;
	}

	// Because back being single digit will lead to next cyclic not being 4 digits 
	for (int back = 10; back < 100; ++back) {
		for (size_t i = 0; i < shapes_used.size(); ++i) {
			if (shapes_used[i]) { continue; }

			const int n = (front * 100) + back;
			if (shape_collection.is_shape(i, n)) {
				shapes_used[i] = true;
				shapes.push_back(n);
				if (recursive_cyclic_shapes(back, shape_collection, shapes_used, shapes)) {
					return true;
				}

				// Didn't work so revert
				shapes_used[i] = false;
				shapes.pop_back();
			}
		}
	}
	return false;
}

/*Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are
all figurate (polygonal) numbers and are generated by the following formulae:

Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
Square	 		P4,n=n*n	 		1, 4, 9, 16, 25, ...
Pentagonal	 	P5,n=n(3n-1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 	P6,n=n(2n-1)	 	1, 6, 15, 28, 45, ...
Heptagonal	 	P7,n=n(5n-3)/2	 	1, 7, 18, 34, 55, ...
Octagonal	 	P8,n=n(3n-2)	 	1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
1.The set is cyclic, in that the last two digits of each number is the first
two digits of the next number (including the last number with the first).
2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882),
is represented by a different number in the set.
3. This is the only set of 4-digit numbers with this property.
Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type:
triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different
number in the set.*/
int q61() {

	shape_number_collection<int> shape_collection;
	shape_collection.add_shape_ptr(new triangle_number<int>);
	shape_collection.add_shape_ptr(new square_number<int>);
	shape_collection.add_shape_ptr(new pentagonal_number<int>);
	shape_collection.add_shape_ptr(new hexagonal_number<int>);
	shape_collection.add_shape_ptr(new heptagonal_number<int>);
	shape_collection.add_shape_ptr(new octagonal_number<int>);

	std::vector<bool> shapes_used(shape_collection.size(), false);

	std::vector<int> shapes;
	for (int front = 10; front < 100; ++front) {
		if (recursive_cyclic_shapes(front, shape_collection, shapes_used, shapes)) {
			break;
		}
	}

	int sum = 0;
	for (size_t i = 0; i < shapes.size(); ++i) {
		sum += shapes[i];
	}

	return sum;
}



/* The cube, 41063625 (345^3), can be permuted to produce two
other cubes: 56623104 (384^3) and 66430125 (405^3). In fact,
41063625 is the smallest cube which has exactly three
permutations of its digits which are also cube. Find the smallest
cube for which exactly five permutations of its digits are cube. */
long long int q62() {
	const int required_perms = 5;

	// Stores digit maps and corresponding cubes
	std::map<std::map<int, unsigned int>, std::vector<long long int> > cube_digit_map;

	long long int base = 0, smallest = 0;

	while (smallest == 0) {
		++base;
		// if (base % 1000 == 0) {cout << "Processing [" << base << "]..." << endl;}

		long long int cube = base * base * base;
		auto digit_map = number_helper::get_digit_map(cube);

		auto it = cube_digit_map.find(digit_map);
		if (it == cube_digit_map.end()) {
			std::vector<long long int> new_vec;
			new_vec.push_back(cube);
			cube_digit_map.insert(std::pair<std::map<int, unsigned int>, std::vector<long long int> >(digit_map, new_vec));
		}
		else {
			it->second.push_back(cube);
			if (it->second.size() == required_perms) {
				smallest = it->second.front();
				break;
			}
		}
	}

	// 5027 127035954683
	// 7061 352045367981
	// 7202 373559126408
	// 8288 569310543872
	// 8384 589323567104

	return smallest;
}


/*The 5-digit number, 16807=7^5, is also a fifth power. Similarly,
the 9-digit number, 134217728=8^9, is a ninth power. How many n-digit
positive integers exist which are also an nth power?*/
int q63() {
	// Observe that for x >= 2, 10^x will have x + 1 digits.
	// Therefore, for an n digit number, need only go so far as checking 9^n.

	int count = 0;
	bool finished = false;
	for (size_t digits = 1; !finished; ++digits) { // Number of digits and required power

		for (int base = 1; base < 10; ++base) {
			vector_int current(1);

			for (size_t i = 0; i < digits; ++i) {
				current *= base;
			}

			// Do we have the correct number of digits?
			if (current.size() == digits) {
				// std::cout << current << " " << base << " " << digits << std::endl;
				++count;
			}
			// Have we already exceeded the number of digits required?
			else if (current.size() > digits) {
				break;
			}
			// Have we not managed to get to the required number of
			// digits even using the biggest base?
			else if (base == 9 && current.size() < digits) {
				finished = true;
				break;
			}
		}
	}

	// Q63. There are [49] n-digit positive integers which are also an nth power.
	// std::cout << "Q63. There are [" << count << "] n-digit positive integers which are also an nth power." << std::endl;

	return count;
}


/*All square roots are periodic when written as continued fractions and can be
written in the form:

For example, let us consider v23:

If we continue we would get the following expansion:

The process can be summarised as follows:

It can be seen that the sequence is repeating. For conciseness, we use the
notation sqrt(23) = [4;(1,3,1,8)], to indicate that the block (1,3,1,8) repeats indefinitely.
The first ten continued fraction representations of (irrational) square roots are:
sqrt(2)=[1;(2)], period=1
sqrt(3)=[1;(1,2)], period=2
sqrt(5)=[2;(4)], period=1
sqrt(6)=[2;(2,4)], period=2
sqrt(7)=[2;(1,1,1,4)], period=4
sqrt(8)=[2;(1,4)], period=2
sqrt(10)=[3;(6)], period=1
sqrt(11)=[3;(3,6)], period=2
sqrt(12)= [3;(2,6)], period=2
sqrt(13)=[3;(1,1,1,1,6)], period=5
Exactly four continued fractions, for N <= 13, have an odd period.
How many continued fractions for N <= 10000 have an odd period?*/
int q64() {
	int count = 0;

	for (int i = 2; i <= 10000; ++i) {
		// if (i % 1000 == 0) { std::cout << i << std::endl; }

		sqrt_cont_frac<int> current(i);

		// std::cout << current << " " << current.to_continued_fraction_representation() << std::endl;

		// Test for even as first entry is outside the repeating portion.
		// Hence, if size is even, then repeating period is odd.
		if (current.get_coefficients().size() % 2 == 0) {
			++count;
		}
	}

	return count; // 1322
}


/*The square root of 2 can be written as an infinite continued fraction.
The infinite continued fraction can be written, v2 = [1;(2)], (2) indicates
that 2 repeats ad infinitum. In a similar way, v23 = [4;(1,3,1,8)].

It turns out that the sequence of partial values of continued fractions for
square roots provide the best rational approximations. Let us consider the
convergents for v2.

Hence the sequence of the first ten convergents for v2 are:
1, 3/2, 7/5, 17/12, 41/29, 99/70, 239/169, 577/408, 1393/985, 3363/2378, ...

What is most surprising is that the important mathematical constant,
e = [2; 1,2,1, 1,4,1, 1,6,1 , ... , 1,2k,1, ...].

The first ten terms in the sequence of convergents for e are:
2, 3, 8/3, 11/4, 19/7, 87/32, 106/39, 193/71, 1264/465, 1457/536, ...
The sum of digits in the numerator of the 10th convergent is 1+4+5+7=17.
Find the sum of digits in the numerator of the 100th convergent of the
continued fraction for e.*/
int q65() {
	int lead_int = 2;
	vector_int num(0), den(0);

	bool first_iteration = true;
	for (int frac_term = 99; frac_term > 0; --frac_term) {
		int coeff = 1;
		if (frac_term % 3 == 2) {
			coeff = 2 * ((frac_term / 3) + 1);
		}

		if (first_iteration) {
			first_iteration = false;
			num = vector_int(1);
			den = vector_int(coeff);
		}
		else {
			vector_int num_sav = num;
			num = den;
			den = (den * coeff) + num_sav;
		}
	}
	// std::cout << (num + (den * lead_int)) << " " << den << std::endl;

	return (num + (den * lead_int)).digit_sum();
}


/*Consider quadratic Diophantine equations of the form: x^2 – D * y^2 = 1
For example, when D=13, the minimal solution in x is 649^2 – 13×180^2 = 1.
It can be assumed that there are no solutions in positive integers when D is square.
By finding minimal solutions in x for D = {2, 3, 5, 6, 7}, we obtain the following:
3^2 – 2×2^2 = 1
2^2 – 3×1^2 = 1
9^2 – 5×4^2 = 1
5^2 – 6×2^2 = 1
8^2 – 7×3^2 = 1
Hence, by considering minimal solutions in x for D <= 7, the largest x is obtained
when D = 5. Find the value of D <= 1000 in minimal solutions of x for which the largest
value of x is obtained.*/
int q66() {

	const int limit = 1000;

	// Have we found the min x for given value of D?
	std::vector<int> D_min_x(limit, false);
	
	// Ignore D = 1
	D_min_x[0] = true;
	size_t count = 1;

	// Assumed no solution when D is square.
	for (int i = 2; true; ++i) {
		int sqr = i * i;
		if (sqr < limit) {
			D_min_x[sqr - 1] = true;
			++count;
		}
		else {
			break;
		}
	}

	// x^2 – D * y^2 = 1
	// x^2 – 1 = D * y^2

	long long int x = 2;
	while (count < (limit - 1)) { // Final D value not found is answer
		const long long int LHS = (x * x) - 1;

		long long int y = std::max(1.0, sqrt(LHS / limit)); // y at least 1
		while (true) {
			const long long int RHS = y * y;

			if (RHS >= LHS) { break; }

			if (LHS % RHS == 0) {
				const int D = LHS / RHS;

				if (D <= limit && !D_min_x[D - 1]) {
					D_min_x[D - 1] = true;
					++count;

					std::cout << count << " " << D << " " << x << " " << y << std::endl;
				}
			}
			++y;
		}
		++x;
	}

	int D_largest_x = 0;
	for (size_t i = 1; i < limit; ++i) {
		if (!D_min_x[i]) {
			D_largest_x = (int)i + 1;
			break;
		}
	}

	return D_largest_x;
}


/* By starting at the top of the triangle below and moving to adjacent
numbers on the row below, the maximum total from top to bottom is 23.
3
7 4
2 4 6
8 5 9 3
That is, 3 + 7 + 4 + 9 = 23.
Find the maximum total from top to bottom in triangle.txt (right click
and 'Save Link/Target As...'), a 15K text file containing a triangle with
one-hundred rows.
NOTE: This is a much more difficult version of Problem 18.
It is not possible to try every route to solve this problem, as there are
299 altogether! If you could check one trillion (1012) routes every second
it would take over twenty billion years to check them all. There is an
efficient algorithm to solve it. ;o) */
int q67() {
	const int max_rows = 100;
	std::vector<std::vector<int> > tree;

	ifstream_with_path fin("Problem67.txt");
	for (int i = 0; i < max_rows; ++i) {
		std::vector<int> row;
		int n;
		for (int j = 0; j <= i; ++j) {
			fin >> n;
			row.push_back(n);
		}
		tree.push_back(row);
	}
	fin.close();

	// Work our way from the tree base up to the tree top formulating maximum path
	for (int i = max_rows - 2; i >= 0; --i) {
		for (int j = 0; j <= i; ++j) {
			// Take larger of left or right on row below
			tree[i][j] += tree[i + 1][j] > tree[i + 1][j + 1] ? tree[i + 1][j] : tree[i + 1][j + 1];
		}
	}

	// Q67. THe maximum total from top to bottom is [7273]
	// std::cout << "Q67. THe maximum total from top to bottom is [" << tree[0][0] << "]" << std::endl;

	return tree.front().front();
}


/*Consider the following "magic" 3-gon ring, filled with the numbers
1 to 6, and each line adding to nine.
Working clockwise, and starting from the group of three with the numerically
lowest external node (4,3,2 in this example), each solution can be described
uniquely. For example, the above solution can be described by the set:
4,3,2; 6,2,1; 5,1,3.
It is possible to complete the ring with four different totals: 9, 10, 11,
and 12. There are eight solutions in total.

Total	Solution Set
9	4,2,3; 5,3,1; 6,1,2
9	4,3,2; 6,2,1; 5,1,3
10	2,3,5; 4,5,1; 6,1,3
10	2,5,3; 6,3,1; 4,1,5
11	1,4,6; 3,6,2; 5,2,4
11	1,6,4; 5,4,2; 3,2,6
12	1,5,6; 2,6,4; 3,4,5
12	1,6,5; 3,5,4; 2,4,6

By concatenating each group it is possible to form 9-digit strings;
the maximum string for a 3-gon ring is 432621513.
Using the numbers 1 to 10, and depending on arrangements, it is possible
to form 16- and 17-digit strings. What is the maximum 16-digit string
for a "magic" 5-gon ring?*/
long long int q68() {
	// To form a 16 digit string we must have number 10 in an external
	// node so that it is only counted once.

	// Digits 1, 2, ..., 10 sum to 55. We get to double count 5 internal
	// nodes, the minimum is SUM(1, 2, ..., 5) = 15, the maximum is
	// SUM(6, 7, ..., 10) = 40. Therefore, each line can be at least
	// (55 + 15) / 5 = 14 and at most (55 + 40) / 5 = 19.

	// Ordinarily, to get the maximal string, you'd want the largest numbers
	// to all be external nodes so that the string starts on the largest
	// number. However, if some numbers have more digits that others, these
	// should be placed internally to produce a longer string. But, as before,
	// 10, the only 2 digit number, must be an external node to produce a 16
	// digit string. We therefore need 6, 7, 8, 9, 10 to be external nodes. 
	// As 1, 2, 3, 4, 5 will be internal nodes, each line must sum to 14. 

	// According to the rules we must start the string at the smallest external
	// node 6. Along the same line we need to add 8 using two digits to total 14.
	// We have to choose 5 and 3 and prefer putting the 5 next to the 6 to get a
	// larger string. By similar deductions we work our way round the ring hoping
	// to complete the ring obeying all the rules. 

	std::vector<int> internal_values;
	internal_values.push_back(1);
	internal_values.push_back(2);
	internal_values.push_back(3);
	internal_values.push_back(4);
	internal_values.push_back(5);

	std::vector<int> external_values;
	external_values.push_back(6);
	external_values.push_back(7);
	external_values.push_back(8);
	external_values.push_back(9);
	external_values.push_back(10);

	magic_five_gon my_magic(internal_values, external_values);

	return my_magic.to_int();
}


/*Euler's Totient function, phi(n) [sometimes called the phi function], is used to determine the number
of numbers less than n which are relatively prime to n. For example, as 1, 2, 4, 5, 7, and 8, are all
less than nine and relatively prime to nine, phi(9)=6.

n Relatively Prime phi(n) n/phi(n)
2 1 1 2
3 1,2 2 1.5
4 1,3 2 2
5 1,2,3,4 4 1.25
6 1,5 2 3
7 1,2,3,4,5,6 6 1.1666...
8 1,3,5,7 4 2
9 1,2,4,5,7,8 6 1.5
10 1,3,7,9 4 2.5
It can be seen that n=6 produces a maximum n/phi(n) for n = 10.
Find the value of n <= 1,000,000 for which n/phi(n) is a maximum.*/
int q69() {
	// Theory to do with Euler's Totient function, phi(n)
	// https://en.wikipedia.org/wiki/Euler%27s_totient_function

	int max_n = 0, limit = 1000000;
	double max = 0;

	for (int n = 2; n <= limit; ++n) {
		// if (n % 10000 == 0) { std::cout << n << std::endl; }

		const int phi_n = factors_helper::phi(n);

		// std::cout << n << " " << phi_n << std::endl;

		const double res = (double)n / (double)phi_n;
		if (res > max) {
			max = res;
			max_n = n;
		}
	}

	return max_n;
}


/*Euler's Totient function, phi(n) [sometimes called the phi function],
is used to determine the number of positive numbers less than or equal to n which
are relatively prime to n. For example, as 1, 2, 4, 5, 7, and 8, are all less
than nine and relatively prime to nine, phi(9)=6.
The number 1 is considered to be relatively prime to every positive number, so phi(1)=1.
Interestingly, phi(87109)=79180, and it can be seen that 87109 is a permutation of 79180.
Find the value of n, 1 < n < 10^7, for which phi(n) is a permutation of n and the ratio
n/phi(n) produces a minimum.*/
int q70() {
	int min_n = 0, limit = 10000000;
	double min = INT_MAX;

	for (int n = 2; n < limit; ++n) {
		// if (n % 10000 == 0) { std::cout << n << std::endl; }

		const int phi_n = factors_helper::phi(n);

		if (!permutation_helper::is_permutation(n, phi_n)) {
			continue;
		}

		const double res = (double)n / (double)phi_n;
		if (res < min) {
			min = res;
			min_n = n;
		}
	}

	return min_n;
}