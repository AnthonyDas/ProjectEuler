#include <vector>
#include <map>
#include <math.h> // exp2()
#include <cstdio> // sprintf()

#include "ifstream_with_path.h"
#include "grid.h"
#include "factors_helper.h"
#include "letter_count_helper.h" 
#include "date.h" 
#include "vector_int.h" 

//---------------------------------------------------------------
// Copyright © (2016) Anthony Das
//---------------------------------------------------------------
// https://projecteuler.net


/* What is the greatest product of four adjacent numbers in the same
direction (up, down, left, right, or diagonally) in the 20×20 grid?*/
int q11() {
	const size_t size = 20;
	grid<int> my_grid(size, size);

	ifstream_with_path fin("Problem11.txt");
	for (size_t i = 0; i < size; ++i) {
		for (size_t j = 0; j < size; ++j) {
			int next;
			if (fin >> next) {
				my_grid[i][j] = next;
			}
		}
	}
	fin.close();
	// LOG_INF(my_grid.to_string());

	int product, max = -1;
	// left to right
	for (size_t i = 0; i < 20; ++i) {
		for (size_t j = 0; j < 17; ++j) {
			product = my_grid[i][j] * my_grid[i][j + 1] * my_grid[i][j + 2] * my_grid[i][j + 3];
			if (product > max) {
				max = product;
			}
		}
	}
	// up and down
	for (size_t i = 0; i < 17; ++i) {
		for (size_t j = 0; j < 20; ++j) {
			product = my_grid[i][j] * my_grid[i + 1][j] * my_grid[i + 2][j] * my_grid[i + 3][j];
			if (product > max) {
				max = product;
			}
		}
	}
	// diagonal: hi left to low right
	for (size_t i = 0; i < 17; ++i) {
		for (size_t j = 0; j < 17; ++j) {
			product = my_grid[i][j] * my_grid[i + 1][j + 1] * my_grid[i + 2][j + 2] * my_grid[i + 3][j + 3];
			if (product > max) {
				max = product;
			}
		}
	}
	// diagonal: low left to hi right
	for (size_t i = 0; i < 17; ++i) {
		for (size_t j = 0; j < 17; ++j) {
			product = my_grid[i][j + 3] * my_grid[i + 1][j + 2] * my_grid[i + 2][j + 1] * my_grid[i + 3][j];
			if (product > max) {
				max = product;
			}
		}
	}

	// New max [70600674], based on diagonal: low left / hi right [89 94 97 87]
	// Greatest product of four adjacent numbers in the same direction [70600674]
	return max;
}



/* The sequence of triangle numbers is generated by adding the natural numbers.
So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
The first ten terms would be:
1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
Let us list the factors of the first seven triangle numbers:
1: 1
3: 1,3
6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
We can see that 28 is the first triangle number to have over five divisors.
What is the value of the first triangle number to have over five hundred divisors?*/
int q12() {
	int triangle = 0, add = 1, divisors = 0;

	while (divisors < 500) {
		triangle += add;
		++add;

		std::map<int, unsigned int> factors;
		factors_helper::factorise(triangle, factors);

		divisors = 1;
		for (std::map<int, unsigned int>::const_iterator it = factors.begin(); it != factors.end(); ++it) {
			divisors *= (it->second + 1);
		}
		// cout << "Triangle [" << triangle << "] divisors [" << divisors << "]" << endl;
	}

	// Q12. Triangle with over five hundred divisors [76576500]
	// cout << "Q12. Triangle with over five hundred divisors [" << triangle << "]" << endl;

	return triangle;
}

// Work out the first ten digits of the sum of the following one-hundred 50-digit numbers.
long long int q13() {
	std::vector<std::string> numbers;

	std::string next;
	ifstream_with_path fin("Problem13.txt"); // creates an ifstream called fin
	while (std::getline(fin, next)) {
		numbers.push_back(next);
	}
	fin.close();

	std::vector<int> sum; // Most significant digit first
	for (size_t i = 0; i < numbers.front().size(); ++i) {
		int digit = 0;
		for (size_t j = 0; j < numbers.size(); ++j) {
			digit += (numbers[j][i] - '0');
		}
		sum.push_back(digit);
	}

	int carry = 0;
	for (std::vector<int>::reverse_iterator rit = sum.rbegin(); rit != sum.rend(); ++rit) {
		*rit += carry; // Add carry over to this digit
		carry = *rit / 10; // Next carry over
		*rit = *rit % 10; // This single digit
	}
	while (carry != 0) {
		int digit = carry % 10;
		carry /= 10;
		sum.insert(sum.begin(), digit);
	}

	// Get first ten digits
	long long int first_ten = 0;
	for (size_t i = 0; i < 10; ++i) {
		first_ten = first_ten * 10 + sum[i];
	}

	// [5 5 3 7 3 7 6 2 3 0 3 9 0 8 7 6 6 3 7 3 0 2 0 4 8 7 4 6 8 3 2 9 8 5 9 7 1 7 7 3
	// 6 5 9 8 3 1 8 9 2 6 7 2 ]
	// cout << largeSum << endl;

	// Q13. First ten digits of sum is [5537376230].
	// cout << "Q13. First ten digits of sum is [" << firstTenDigits << "]." << endl;

	return first_ten;
}

template<typename T>
T collatz(const T &a) {
	if (a % 2 == 0) {
		return a / 2;
	}
	else {
		return (3 * a) + 1;
	}
}


// The following iterative sequence is defined for the set of positive integers:
// n -> n/2 (n is even)
// n -> 3n + 1 (n is odd)
// Using the rule above and starting with 13, we generate the following sequence:
// 13 -> 40 -> 20 -> 10 -> 5 -> 16 -> 8 -> 4 -> 2 -> 1
// It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms.
// Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.
// Which starting number, under one million, produces the longest chain?
// NOTE: Once the chain starts the terms are allowed to go above one million.
int q14() {
	unsigned long int max_count = 0, max_number = 0;

	for (unsigned int i = 2; i <= 1000000; ++i) {
		unsigned long int next = i, count = 1;

		while (next != 1) {
			next = collatz(next);
			count++;
		}
		if (count > max_count) {
			max_count = count;
			max_number = i;
			// cout << "Current starting number [" << i << "] count [" << maxCount << "]" << endl;
		}
	}
	// Q14. Starting number [837799] count [525]
	// cout << "Q14. Starting number [" << maxNumber << "] count [" << maxCount << "]" << endl;

	return max_number;
}


template<typename T>
long long int grid_paths(const int &rows, const int &cols, grid<T> &grids_already_calculated) {
	if (rows == 0 || cols == 0) {
		return 1;
	}

	if (grids_already_calculated[rows - 1][cols - 1] != 0) {
		return grids_already_calculated[rows - 1][cols - 1];
	}

	grids_already_calculated[rows - 1][cols - 1] = grid_paths(rows, cols - 1, grids_already_calculated) + grid_paths(rows - 1, cols, grids_already_calculated);

	 return grids_already_calculated[rows - 1][cols - 1];
}

/* Starting in the top left corner of a 2x2 grid, there are 6 routes
(without backtracking) to the bottom right corner.
How many routes are there through a 20x20 grid? */
long long int q15() {
	const int size = 20;

	// We solve by recursion, and to save computational time,
	// record solutions for smaller/intermediate grids already calculated 
	grid<long long int> grids_already_calculated(size, size);

	return grid_paths(size, size, grids_already_calculated);
}


// 2^15 = 32768 and the sum of its digits is 3 + 2 + 7 + 6 + 8 = 26.
// What is the sum of the digits of the number 2^1000?
int q16() {
	/*vector_int res(1);

	for (int i = 0; i < 1000; ++i) {
		res = res * 2;
	}

	// std::cout << "2^1000:" << res << std::endl;
	int digit_sum = res.digit_sum();

	// Q16. 2^1000 sum of digits: 1366
	// cout << "Q16. 2^1000 sum of digits: " << digitSum << endl;

	return digit_sum;*/

	// https://en.wikipedia.org/wiki/Double-precision_floating-point_format
	// Since we are dealing with raising 2 to 1000 we can use a trick exploiting
	// how doubles are represented. Ordinarily, doubles only have 15 significant
	// digits of accuracy. However, for a power of 2, they will be exact up to the
	// power of 2^10 = 1024. This is because 11 bits are reserved for the exponent
	// of 2 (max e = 2^11 = 2048) after which the power of 2 is calculated as (e - 1023) 
	// = 1025. As 1000 < 1025, we can simply use the double data type for the calculation.

	const double n = 1000.0;

	double result = exp2(n);

	// Calculate number of digits in 2^n.
	// 10^x = 2^n
	// x.log2(10) = n.log2(2) = n
	// x = n / log2(10).
	// But note that 10^1 is actually a 2 digit number.
	const int len = (int)(floor(n / log2(10)) + 1);

	// Allocate digit string buffer.
	char *result_str = new char[len + 1]; // + 1 for termination char \0

	// Buffer the result into the char array.
	// On failure a negative int is returned.
	// sprintf: On success, the total number of characters written is returned not
	// including the additional null-character automatically appended. On failure,
	// a negative number is returned.
	if (sprintf(result_str, "%.0f", result) < 0) { // ".0" = no decimals, "f" = float
		throw std::runtime_error("Error writing to digit string");
	}

	int digit_sum = 0;
	for (int i = 0; i < len; i++) {
		digit_sum += result_str[i] - '0';
	}

	delete[] result_str;

	return digit_sum;
}


/*If the numbers 1 to 5 are written out in words: one, two, three, four, five,
then there are 3 + 3 + 5 + 4 + 4 = 19 letters used in total.
If all the numbers from 1 to 1000 (one thousand) inclusive were written out in words, how many letters would be used?
NOTE: Do not count spaces or hyphens. For example, 342 (three hundred and forty-two) contains
23 letters and 115 (one hundred and fifteen) contains 20 letters.
The use of "and" when writing out numbers is in compliance with British usage.*/
int q17() {
	int count = 0;

	for (int i = 1; i <= 1000; ++i) {
		count += letter_count_helper::number_letter_count(i);
	}

	// Q17. Letter count = [21124]
	// cout << "Q17. Letter count = [" << count << "]" << endl; 

	return count;
}


/* Maximum path sum I
By starting at the top of the triangle below and moving to adjacent
numbers on the row below, the maximum total from top to bottom is 23.
3
7 4
2 4 6
8 5 9 3
That is, 3 + 7 + 4 + 9 = 23.
Find the maximum total from top to bottom of the triangle below.
NOTE: As there are only 16384 routes, it is possible to solve this problem by
trying every route. However, Problem 67, is the same challenge with a triangle
containing one-hundred rows; it cannot be solved by brute force, and requires
a clever method!*/
int q18() {
	ifstream_with_path fin("Problem18.txt");

	int max_rows = 15;
	std::vector<std::vector<int> > tree;
	for (int i = 0; i < max_rows; ++i) {
		std::vector<int> row;
		for (int j = 0; j <= i; ++j) {
			int next;
			fin >> next;
			row.push_back(next);
			// cout << next << " ";
		}
		tree.push_back(row);
		// cout << endl;
	}
	fin.close();

	for (int i = max_rows - 2; i >= 0; --i) { // Start on second to last row
		for (int j = 0; j <= i; ++j) {
			tree[i][j] += tree[i + 1][j] > tree[i + 1][j + 1] ? tree[i + 1][j] : tree[i + 1][j + 1];
		}
	}

	/* for (int i = 0; i < maxrows; ++i) {
	for (int j = 0; j <= i; ++j) {
	cout << tree[i][j] << " ";
	}
	cout << endl;
	} */

	// Q18. Maximum path sum is: 1074
	// cout << "Q18. Maximum path sum is: " << tree[0][0] << endl;

	return tree[0][0];
}


/*You are given the following information, but you may prefer to do some research for yourself.
1 Jan 1900 was a Monday.
Thirty days has September,
April, June and November.
All the rest have thirty-one,
Saving February alone,
Which has twenty-eight, rain or shine.
And on leap years, twenty-nine.
A leap year occurs on any year evenly divisible by 4, but not on a century unless it is divisible by 400.
How many Sundays fell on the first of the month during the twentieth century (1 Jan 1901 to 31 Dec 2000)?*/
int q19() {
	// Date class automatically sets day of week
	date<int> my_date(1, 1, 1901);

	// Set to Sunday
	if (my_date.get_day_of_week() != SUN) {
		int to_add = (int)SUN - (int)my_date.get_day_of_week();
		my_date.add_days(to_add);
	}

	int count = 0;
	while (my_date.get_year() != 2001) {
		if (my_date.get_day() == 1) {
			++count;
		}
		my_date.add_days(7); // Always stays on SUN
	}

	// Q19. Sundays falling on first of month during the twentieth century [171]
	// cout << "Q19. Sundays falling on first of month during the twentieth century [" << count << "]" << endl; 

	return count;
}

// n! means n × (n - 1) × ... × 3 × 2 × 1
// For example, 10! = 10 × 9 × ... × 3 × 2 × 1 = 3628800,
// and the sum of the digits in the number 10! is 3 + 6 + 2 + 8 + 8 + 0 + 0 = 27.
// Find the sum of the digits in the number 100!
int q20() {
	vector_int res(1);

	for (int i = 2; i <= 100; ++i) {
		res = res * i;
	}

	// std::cout << "100!:" << res << std::endl;
	int digit_sum = res.digit_sum();

	// [9 3 3 2 6 2 1 5 4 4 3 9 4 4 1 5 2 6 8 1 6 9 9 2 3 8 8 5 6 2 6 6 7 0 0 4 9 0 7 1
	// 5 9 6 8 2 6 4 3 8 1 6 2 1 4 6 8 5 9 2 9 6 3 8 9 5 2 1 7 5 9 9 9 9 3 2 2 9 9 1 5
	// 6 0 8 9 4 1 4 6 3 9 7 6 1 5 6 5 1 8 2 8 6 2 5 3 6 9 7 9 2 0 8 2 7 2 2 3 7 5 8 2
	// 5 1 1 8 5 2 1 0 9 1 6 8 6 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ]
	//cout << res;

	// Q20. 100! sum of digits is: 648
	// std::cout << "Q20. 100! sum of digits is: " << digit_sum << std::endl;

	return digit_sum;
}
