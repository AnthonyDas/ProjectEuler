#include "prime_helper.h"
#include "factors_helper.h"
#include "fibonacci_helper.h"
#include "palindrome_helper.h"

#include "ifstream_with_path.h"

#include <map>

//---------------------------------------------------------------
// Copyright © (2016) Anthony Das
//---------------------------------------------------------------
// https://projecteuler.net


// If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9.
// The sum of these multiples is 23. Find the sum of all the multiples of 3 or 5 below 1000.
int q1() {
	int n = 999, total = 0;
	for (int i = 1; i <= n; ++i) {
		if ((i % 3 == 0) || (i % 5 == 0)) {
			total += i;
		}
	}

	return total;
}

int q1_quick() {
	const int n = 999;
	return factors_helper::sum_divisible_by(n, 3) + factors_helper::sum_divisible_by(n, 5) - factors_helper::sum_divisible_by(n, 15);
}

// Each new term in the Fibonacci sequence is generated by adding the previous two terms.
// By starting with 1 and 2, the first 10 terms will be:
// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
// By considering the terms in the Fibonacci sequence whose values do not exceed four million,
// find the sum of the even-valued terms.
int q2() {
	int total = 0, x, y = 1, z = 2;
	while (z <= 4000000) {
		if (z % 2 == 0) {
			total += z;
		}

		x = y;
		y = z;
		z = x + y;
	}

	return total;
}

int q2_quick() {
	const int n = 4000000;
	return fibonacci_helper::sum_even_fibonacci(n);
}

// The prime factors of 13195 are 5, 7, 13 and 29.
// What is the largest prime factor of the number 600851475143?
long long int q3() {
	long long int n = 600851475143, last_prime_factor = -1;

	if (n % 2 == 0) {
		last_prime_factor = 2;
		n /= 2;
		while (n % 2 == 0) {
			n /= 2;
		}
	}

	for (long long int i = 3; i*i <= n; i += 2) {
		if (n % i == 0) {
			last_prime_factor = i;
			n /= i;
			while (n % i == 0) {
				n /= i;
			}
		}
	}

	if (n != 1) {
		last_prime_factor = n;
	}

	return last_prime_factor;
}

long long int q3_quick() {
	long long int n = 600851475143;

	std::map<long long int, unsigned int> factors;
	factors_helper::factorise(n, factors);

	return factors.rbegin()->first;
}

// A palindromic number reads the same both ways.
// The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
// Find the largest palindrome made from the product of two 3-digit numbers.
int q4() {
	int largest = 0;

	for (int i = 999; i > 99; --i) {
		for (int j = i; j > 99; --j) {
			if (largest < (i * j) && palindrome_helper::is_palindrome(i * j)) {
				largest = i * j;

				// std::cout << largest << " " << i << " " << j << std::endl;
			}
		}
	}

	return largest;
}

// 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
// What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?
long long int q5() {
	int n = 20;

	long long int N = 1;

	for (int i = 2; i <= n; ++i) {
		if (prime_helper::is_prime(i)) {
			// If i is greater that sqrt(n) then power of i must be 1
			if (i*i <= n) {
				N *= (long long int)pow(i, floor(log(n) / log(i)));
			}
			else {
				N *= i;
			}
		}
	}

	return N;
}

// The sum of the squares of the first ten natural numbers is,
// 1^2 + 2^2 + ... + 10^2 = 385
// The square of the sum of the first ten natural numbers is,
// (1 + 2 + ... + 10)^2 = 552 = 3025
// Hence the difference between the sum of the squares of the first ten natural numbers and the square of the sum is 3025 - 385 = 2640.
// Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
long long int q6() {
	long long int n = 100, square_sum = 0, sum_square = 0;

	for (int i = 1; i <= n; ++i) {
		square_sum += i;
		sum_square += i * i;
	}

	square_sum *= square_sum;

	return square_sum - sum_square;
}


long long int q6_quick() {
	long long int n = 100, square_sum, sum_square;

	// Find the sum of first n numbers
	square_sum = ((n + 1) * n) / 2;
	// Then square
	square_sum *= square_sum;

	// Sum of squares forms a difference equation with stable 3rd level difference.
	// Hence from trying equation of form f(n) = a.n^3 + b.n^2 + c.n + d 
	// and plugging in values for small n and solving simultaneous equations 
	// we derive the formula for f(n) which can be factorised as:
	sum_square = (((2 * n) + 1) * (n + 1) * n) / 6;

	return square_sum - sum_square;
}

// By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see that the 6th prime is 13.
// What is the 10001st prime number?
int q7() {
	// Already include n = 2 (the only even prime)
	int count = 1, n = 3;

	while (true) {
		if (prime_helper::is_prime(n)) {
			if (++count == 10001) {
				break;
			}
		}
		n += 2; // Next odd number
	}

	return n;
}

// Find the greatest product of five consecutive digits in the 1000-digit number.
long long int q8() {
	std::string sequence, next;
	/*sequence.append("73167176531330624919225119674426574742355349194934");
	sequence.append("96983520312774506326239578318016984801869478851843");
	sequence.append("85861560789112949495459501737958331952853208805511");
	sequence.append("12540698747158523863050715693290963295227443043557");
	sequence.append("66896648950445244523161731856403098711121722383113");
	sequence.append("62229893423380308135336276614282806444486645238749");
	sequence.append("30358907296290491560440772390713810515859307960866");
	sequence.append("70172427121883998797908792274921901699720888093776");
	sequence.append("65727333001053367881220235421809751254540594752243");
	sequence.append("52584907711670556013604839586446706324415722155397");
	sequence.append("53697817977846174064955149290862569321978468622482");
	sequence.append("83972241375657056057490261407972968652414535100474");
	sequence.append("82166370484403199890008895243450658541227588666881");
	sequence.append("16427171479924442928230863465674813919123162824586");
	sequence.append("17866458359124566529476545682848912883142607690042");
	sequence.append("24219022671055626321111109370544217506941658960408");
	sequence.append("07198403850962455444362981230987879927244284909188");
	sequence.append("84580156166097919133875499200524063689912560717606");
	sequence.append("05886116467109405077541002256983155200055935729725");
	sequence.append("71636269561882670428252483600823257530420752963450");*/

	// Be wary the file only contains \n and not \r\n - check in Notepad++
	ifstream_with_path fin("Problem8.txt");
	while (std::getline(fin, next)) {
		sequence.append(next);
	}
	fin.close();

	const int length = 13;
	long long int product, largest_product = 0;

	for (size_t i = 0; i < sequence.size() - length + 1; ++i) {
		product = 1;
		for (size_t j = i; j < i + length; ++j) {
			// Cast char to int and remember the offset
			product *= ((int)sequence[j] - (int)'0');
		}
		if (product > largest_product) {
			largest_product = product;
		}
	}

	// CAN'T USE THE BELOW SMARTER CODE AS SEQUENCE CONTAINS ZERO DIGITS
	/*product = 1;
	for (size_t i = 0; i < length; ++i) {
	// Cast char to int and remember the offset
	product *= (int)sequence[i] - (int)'0';
	}
	largest_product = product;

	for (size_t j = 0; j < sequence.size() - length; ++j) {
	product /= ((int)sequence[j] - (int)'0');
	product *= ((int)sequence[j + length] - (int)'0');
	if (product > largest_product) {
	largest_product = product;
	}
	}*/

	return largest_product;
}

// A Pythagorean triplet is a set of three natural numbers, a < b < c, for which,
// a^2 + b^2 = c^2
// For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
// There exists exactly one Pythagorean triplet for which a + b + c = 1000.
// Find the product abc.
int q9() {
	int n = 1000, product = -1;

	// We have two equations: 
	// a + b + c = n  ==>  a = n - (b + c)
	// a*a + b*b = c*c

	// Since n is known, and as there are three variables (a, b, c)
	// with two equations, we can reduce the search to a linear
	// search, i.e. O(n);

	// a^2 + b^2 = c^2
	// (n - (b + c))^2 + b^2 = c^2
	// n^2 - 2n(b + c) + (b + c)^2 + b^2 = c^2
	// n^2 - 2nb - 2nc + b^2 + 2bc + c^2 + b^2 = c^2
	// n^2 - 2nb - 2nc + 2.b^2 + 2bc = 0
	// n^2 - 2nb + 2.b^2 = 2c(n - b)
	// (n^2)/2 - nb + b^2 = c(n - b)
	// c = ((n^2)/2 - nb + b^2) / (n - b)

	// a < b < c
	for (int b = 2; b < n - 1; ++b) {
		int c = ((n * n) / 2) - (n * b) + (b * b);

		if (c % (n - b) != 0) {
			continue;
		}

		c /= (n - b);

		int a = n - b - c;

		if (a >= b || b >= c) {
			continue;
		}

		product = a * b * c;
		break;
	}

	return product;
}

// The sum of the primes below 10 is 2 + 3 + 5 + 7 = 17.
// Find the sum of all the primes below two million.
long long int q10() {
	const int limit = 2000000;
	long long int sum = 5; // Include primes 2 and 3

	// All primes greater than 3 can be written in the form 6k +/- 1.	
	for (int n = 5; n < limit; n += 6) {
		if (prime_helper::is_prime(n)) {
			sum += n;
		}
		if ((n + 2) < limit && prime_helper::is_prime(n + 2)) {
			sum += n + 2;
		}
	}

	return sum;
}

long long int q10_quick() {
	const long long int limit = 2000000 - 1;

	return prime_helper::sum_prime(limit);
}
